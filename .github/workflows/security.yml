name: Security Scanning

on:
  schedule:
    # Run weekly on Sundays at 3 AM UTC
    - cron: "0 3 * * 0"
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

env:
  PYTHONUNBUFFERED: 1

jobs:
  security-scan:
    name: Security Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install security tools
        run: |
          python -m pip install --upgrade pip
          pip install bandit safety semgrep

      - name: Run Safety (vulnerability database)
        run: |
          safety check --json > safety-results.json || true
          cat safety-results.json

      - name: Run Bandit (static analysis)
        run: |
          bandit -r ai_onboard/ -f json -o bandit-results.json || true
          cat bandit-results.json

      - name: Run Semgrep (semantic analysis)
        run: |
          semgrep --config auto --json > semgrep-results.json || true
          cat semgrep-results.json

      - name: Run Trivy (container scanning)
        uses: aquasecurity/trivy-action@v0.19.2
        with:
          scan-type: fs
          format: json
          output: trivy-results.json
          ignore-unfixed: true
          exit-code: '0'
      - name: Show Trivy results
        run: cat trivy-results.json || true

      - name: Generate security report
        run: |
          python - <<'PY'
import json
from pathlib import Path

paths = {
    'safety': Path('safety-results.json'),
    'bandit': Path('bandit-results.json'),
    'semgrep': Path('semgrep-results.json'),
    'trivy': Path('trivy-results.json'),
}

results = {}
for name, pth in paths.items():
    if pth.exists():
        try:
            results[name] = json.load(pth.open())
        except json.JSONDecodeError:
            results[name] = None
    else:
        results[name] = None

critical = 0
safety_data = results.get('safety')
if isinstance(safety_data, dict):
    vulnerabilities = safety_data.get('vulnerabilities', [])
    critical = sum(1 for item in vulnerabilities if str(item.get('severity', '')).lower() == 'critical')

Path('critical-count.txt').write_text(str(critical))

report_lines = ['# Security Scan Summary', '']
for key in ('safety', 'bandit', 'semgrep', 'trivy'):
    report_lines.append(f"## {key.title()}")
    data = results.get(key)
    if not data:
        report_lines.append('No data available.')
    elif isinstance(data, dict):
        fields = ', '.join(sorted(data.keys()))
        report_lines.append(f'Fields: {fields}')
    else:
        report_lines.append('Results captured.')
    report_lines.append('')

report_lines.append(f'Critical vulnerabilities detected: {critical}')
report_lines.append('')
Path('security-report.md').write_text('
'.join(report_lines), encoding='utf-8')
PY

      - name: Upload security results
        uses: actions/upload-artifact@v3
        with:
          name: security-scan-results
          path: |
            *-results.json
            security-report.md
            critical-count.txt
          retention-days: 30

      - name: Fail on critical vulnerabilities
        run: |
          CRITICAL_COUNT=$(cat critical-count.txt 2>/dev/null || echo 0)
          if [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "Found $CRITICAL_COUNT critical security vulnerabilities!"
            exit 1
          fi


      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e .[dev,test]
          pip install pipdeptree

      - name: Generate dependency tree
        run: |
          pipdeptree --json > dependency-tree.json
          pipdeptree --graph-output png > dependency-graph.png || true

      - name: Check for outdated packages
        run: |
          pip list --outdated --format=json > outdated-packages.json || true

      - name: Analyze dependencies
        run: |
          python - <<'PY'
import json
from pathlib import Path

tree_path = Path('dependency-tree.json')
outdated_path = Path('outdated-packages.json')
output = Path('dependency-analysis.md')

report_lines = ['# Dependency Analysis', '']

if tree_path.exists():
    try:
        tree = json.load(tree_path.open())
        report_lines.append(f"Resolved packages: {len(tree)}")
    except json.JSONDecodeError:
        report_lines.append('Unable to parse dependency tree.')
else:
    report_lines.append('Dependency tree not available.')

report_lines.append('')
if outdated_path.exists():
    try:
        outdated = json.load(outdated_path.open())
        if outdated:
            report_lines.append('## Outdated Packages')
            for item in outdated:
                name = item.get('name', 'unknown')
                current = item.get('version', 'n/a')
                latest = item.get('latest_version', 'n/a')
                report_lines.append(f"- {name}: {current} -> {latest}")
        else:
            report_lines.append('No outdated packages found.')
    except json.JSONDecodeError:
        report_lines.append('Unable to parse outdated packages list.')
else:
    report_lines.append('Outdated package list not available.')

report_lines.append('')
output.write_text('\n'.join(report_lines), encoding='utf-8')
PY

      - name: Upload dependency analysis
        uses: actions/upload-artifact@v3
        with:
          name: dependency-analysis
          path: |
            dependency-tree.json
            dependency-graph.png
            outdated-packages.json
            dependency-analysis.md
          retention-days: 30





